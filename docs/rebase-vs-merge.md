# 🤔 Rebase vs Merge

`git rebase` 和 `git merge` 都是将一个分支的更改合并到另一个分支的方法，但它们实现的方式和产生的历史记录不同。

## Git Merge (合并)

-   **工作方式:** `git merge` 会将两个分支的最新快照以及它们最近的共同祖先进行三方合并，生成一个新的 **合并提交 (Merge Commit)**。
-   **历史记录:** 保留了分支的完整历史，包括分支创建和合并的节点。历史记录图会呈现分叉和合并的结构。
-   **优点:**
    -   非破坏性操作，不修改现有提交。
    *   保留了精确的历史记录，清晰地展示了分支何时合并。
    *   对于共享分支（如 `main`, `develop`）更安全，因为它不会改变其他协作者已经拉取的历史。
-   **缺点:**
    -   如果分支活动频繁，会产生很多合并提交，可能使提交历史变得混乱和难以阅读。

**示例场景:** 将 `feature` 分支合并到 `main` 分支。

```bash
# 1. 切换到目标分支 (main)
git checkout main

# 2. 拉取最新代码 (确保 main 是最新的)
git pull origin main

# 3. 执行合并
git merge feature

# 4. (如果需要) 推送合并后的 main 分支
git push origin main
```

合并后的历史（简化图示）：

```
      A---B---C---M <<< main (合并提交 M)
     /           /
D---E---F---G <<< feature
```

## Git Rebase (变基)

-   **工作方式:** `git rebase` 会找到两个分支（当前分支和目标基底分支）的最近共同祖先，然后将当前分支上的提交 **逐个地** 应用到目标基底分支的最新提交之后。它 **重写** 了当前分支的提交历史。
-   **历史记录:** 产生一个线性的提交历史，看起来好像所有开发都是在一条直线上顺序进行的。
-   **优点:**
    -   使提交历史更简洁、线性，易于阅读和理解。
    *   避免了不必要的合并提交。
-   **缺点:**
    -   **破坏性操作:** 它会修改（重写）提交的 SHA-1 值。**绝对不要在已经推送到共享远程仓库的分支上执行 rebase**，因为这会给其他协作者带来麻烦（他们需要强制更新或进行复杂的修复）。
    *   丢失了合并发生的上下文信息（没有合并提交）。
    *   解决冲突可能更复杂：如果 rebase 过程中有多个提交与基底分支冲突，你需要逐个解决这些冲突。

**示例场景:** 将 `feature` 分支变基到 `main` 分支上。

```bash
# 1. 切换到要变基的分支 (feature)
git checkout feature

# 2. 拉取目标基底分支的最新代码 (确保获取最新的 main)
git fetch origin main # 或者 git pull upstream main (如果配置了 upstream)

# 3. 执行变基 (将 feature 的提交应用到 origin/main 的顶部)
git rebase origin/main # 或者 git rebase main (如果本地 main 是最新的)

# 4. (如果需要) 强制推送到你自己的远程 feature 分支 (因为历史被重写)
git push origin feature --force-with-lease # 比 --force 更安全
```

变基后的历史（简化图示）：

```
D---E---A'--B'--C' <<< feature (提交 A, B, C 被重新应用为 A', B', C')
     \
      F---G <<< main
```
之后，你可以切换回 `main` 分支，并进行一次 "快进合并" (fast-forward merge)，因为 `feature` 分支现在直接基于 `main` 的最新提交：
```bash
git checkout main
git merge feature # 这通常会是一个快进合并，不会产生合并提交
git push origin main
```
最终历史：
```
D---E---F---G---A'--B'--C' <<< main, feature
```

## 如何选择？

-   **合并到共享分支 (如 `main`, `develop`) 时:** **优先使用 `git merge`**。这保留了历史记录，并且对其他协作者是安全的。
-   **在本地私有分支上同步远程分支的更新时:** **可以使用 `git rebase`**。例如，在你的 `feature` 分支上开发时，定期 `git rebase origin/main` 可以保持你的分支基于最新的主线代码，使提交历史线性化，并在最终合并回 `main` 时减少冲突的可能性。
-   **清理本地提交历史:** 在将本地分支推送到远程或创建 Pull Request 之前，可以使用 **交互式 Rebase (`git rebase -i`)** 来整理、合并、修改你的本地提交，使其更清晰。

**黄金法则:** **永远不要 rebase 那些已经被推送到公共仓库并且可能被其他人拉取的分支。** 只在你自己的本地、私有分支上进行 rebase。

**总结:**

| 特性         | `git merge`                     | `git rebase`                       |
| :----------- | :------------------------------ | :--------------------------------- |
| **操作方式** | 三方合并，创建新的合并提交      | 逐个应用提交，重写历史             |
| **历史记录** | 非线性，保留分支结构和合并点    | 线性，简洁                         |
| **安全性**   | 安全 (非破坏性)                 | 危险 (破坏性，不要用于共享分支)    |
| **冲突解决** | 一次性解决所有冲突              | 可能需要逐个提交解决冲突           |
| **适用场景** | 合并共享分支，保留精确历史      | 清理本地历史，同步私有分支与主线 |
